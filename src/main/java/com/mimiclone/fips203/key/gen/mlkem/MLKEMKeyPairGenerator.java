package com.mimiclone.fips203.key.gen.mlkem;

import com.mimiclone.fips203.codec.Codec;
import com.mimiclone.fips203.codec.MLKEMCodec;
import com.mimiclone.fips203.hash.Hash;
import com.mimiclone.fips203.hash.MLKEMHash;
import com.mimiclone.fips203.key.KeyPair;
import com.mimiclone.fips203.ParameterSet;
import com.mimiclone.fips203.key.gen.KeyPairGeneration;
import com.mimiclone.fips203.key.gen.KeyPairGenerationException;
import com.mimiclone.fips203.key.mlkem.MLKEMKeyPair;
import com.mimiclone.fips203.sampler.MLKEMSampler;
import com.mimiclone.fips203.sampler.Sampler;
import com.mimiclone.fips203.transforms.MLKEMNumberTheoreticTransform;
import com.mimiclone.fips203.transforms.NumberTheoreticTransform;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;

import java.nio.ByteBuffer;

@RequiredArgsConstructor(access = AccessLevel.PRIVATE)
public final class MLKEMKeyPairGenerator implements KeyPairGeneration {

    private final ParameterSet parameterSet;

    final Codec codec;

    final Hash hash;

    final Sampler sampler;

    final NumberTheoreticTransform ntt;

    public static MLKEMKeyPairGenerator create(ParameterSet parameterSet) {
        return new MLKEMKeyPairGenerator(
                parameterSet,
                MLKEMCodec.create(parameterSet),
                MLKEMHash.create(parameterSet),
                MLKEMSampler.create(parameterSet),
                MLKEMNumberTheoreticTransform.create(parameterSet)
        );
    }

    /**
     * Implements Algorithm 16 (ML-KEM.KeyGen_internal) of the FIPS203 Specification
     *
     * @param d A byte array of exactly length 32 of randomly generated noise
     * @param z A byte array of exactly length 32 of randomly generated noise
     *
     * @return FIPS203KeyPair
     */
    @Override
    public KeyPair generateKeyPair(byte[] d, byte[] z) {

        // Ensure d exists and is 32 bytes long
        if (d == null || d.length != 32) {
            throw new KeyPairGenerationException("Entropy source 'd' must be 32 bytes");
        }

        // Ensure z exists and is 32 bytes long
        if (z == null || z.length != 32) {
            throw new KeyPairGenerationException("Entropy source 'z' must be 32 bytes");
        }

        // Call K-PKE.KeyGen
        KeyPair baseKeyPair = generateKPKE(d);

        // Retrieve bytes array for the pke keys
        byte[] ekPKE = baseKeyPair.getEncapsulationKey().getBytes();
        byte[] dkPKE = baseKeyPair.getDecapsulationKey().getBytes();

        // Hash the encapsulation key
        byte[] ekHash = hash.hHash(ekPKE);

        // Calculate byte length of decaps key components
        int dkResultLength = dkPKE.length + ekPKE.length + ekHash.length + z.length;

        // Allocate byte array for composite decaps key
        byte[] dkResult = new byte[dkResultLength];
        ByteBuffer dkResultBuffer = ByteBuffer.wrap(dkResult);
        dkResultBuffer.put(dkPKE)
                .put(ekPKE)
                .put(ekHash)
                .put(z);

        // Create result keypair
        // The implementation itself will make a copy of the key bytes, so we don't need to
        // worry about it being modified by outside code.
        return MLKEMKeyPair.fromBytes(ekPKE, dkResult);

    }

    /**
     * Implements Algorithm 13 of the FIPS203 Specification.
     * This is described in Section 5.1 of the August 13 Spec Release starting on Page 28
     *
     * @param d An array of exactly 32 randomly generated bytes.
     *
     * @return An initial FIPS203KeyPair instance
     */
    KeyPair generateKPKE(byte[] d) {

        // Ensure d exists and is 32 bytes long
        if (d == null || d.length != 32) {
            throw new KeyPairGenerationException("Entropy source 'd' must be 32 bytes");
        }

        // Get k as a byte value from parameter set
        int k = parameterSet.getK();
        byte[] kb = { (byte) k };

        // 1: Expand 32 + 1 bytes to two pseudorandom 32-byte seeds
        byte[] dk = new byte[33];
        ByteBuffer buffer = ByteBuffer.wrap(dk);
        buffer.put(d);
        buffer.put(kb);

        // Generate the combined seeds
        byte[] rhoAndSigma = hash.gHash(dk);
        if (rhoAndSigma == null || rhoAndSigma.length != 64) {
            throw new KeyPairGenerationException("Unable to generate 'rho' and 'sigma' 32-byte seed values");
        }

        // Wrap rhoAndSigma in a ByteBuffer for future reads
        ByteBuffer rhoAndSigmaBuffer = ByteBuffer.wrap(rhoAndSigma);

        // Split out rho
        byte[] rho = new byte[32];
        rhoAndSigmaBuffer.get(rho);

        // Split out sigma
        byte[] sigma = new byte[32];
        rhoAndSigmaBuffer.get(sigma);

        int n = 0;

        int[][][] aHatMatrix = new int[k][k][256];

        // Generate A hat matrix
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < k; j++) {
                aHatMatrix[i][j] = sampler.sampleNTT(rho, (byte) j, (byte) i);
            }
        }

        // Generate s
        int[][] s = new int[k][256];
        for (int i = 0; i < k; i++) {
            s[i] = sampler.samplePolyCBDEta1(hash.prfEta1(sigma, (byte) n));
            n++;
        }

        // Generate e
        int[][] e = new int[k][256];
        for (int i = 0; i < k; i++) {
            e[i] = sampler.samplePolyCBDEta1(hash.prfEta1(sigma, (byte) n));
            n++;
        }

        // Calculate sHat
        int[][] sHat = new int[k][256];
        for (int i = 0; i < k; i++) {
            sHat[i] = ntt.transform(s[i]);
        }

        // Calculate eHat
        int[][] eHat = new int[k][256];
        for (int i = 0; i < k; i++) {
            eHat[i] = ntt.transform(e[i]);
        }

        // Noisy linear system in NTT domain
        int[][] tHat = ntt.matrixAdd(ntt.matrixMultiply(aHatMatrix, sHat), eHat);

        // ByteEncode ekPKE and append rho
        byte[] ekPKE = new byte[384*k+32];
        ByteBuffer ekPKEBuffer = ByteBuffer.wrap(ekPKE);
        for (int i = 0; i < k; i++) {
            ekPKEBuffer.put(codec.byteEncode(12, tHat[i]));
        }
        ekPKEBuffer.put(rho);

        // ByteEncode dkPKE
        byte[] dkPKE = new byte[384*k];
        ByteBuffer dkPKEBuffer = ByteBuffer.wrap(dkPKE);
        for (int i = 0; i < k; i++) {
            dkPKEBuffer.put(codec.byteEncode(12, sHat[i]));
        }

        // Create and return the wrapped KeyPair
        return MLKEMKeyPair.fromBytes(ekPKE, dkPKE);
    }

}
